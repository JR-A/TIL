## 빅오 표기법(big-O notation)

알고리즘 문제를 해결하는 코드를 작성할 때, 이 프로그램이 **얼마나 효율적인지** 알고 싶은 경우

1. 수행시간
2. 사용한 메모리
3. 코드의 길이

중 **수행시간**이 가장 중요하다.
왜냐하면, 메모리가 부족하면 램을 구매하면 되지만, 수행시간이 30일이 걸리면 정말로 30일동안 실행시켜야 하기 때문이다.


### 시간 복잡도

시간복잡도는 점근적 표기법(asymptotic notation) 으로 나타내는데 다음 세 가지가 있다.

 >- 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
 >- 평균의 경우 : 세타 표기법 (Big-θ Notation)
 >- **최악의 경우 : 빅오 표기법 (Big-O Notation)**

**big-O 시간**은 **알고리즘의 효율성을 나타내는 지표 혹은 언어**다. big-O를 이용하여 나의 알고리즘이 이전보다 빨라졌는지 느려졌는지 판단한다. 시간복잡도와 공간복잡도가 존재하나 보통 시간복잡도를 계산해보고 시간 안에 수행된다면 공간복잡도는 크게 걱정하지 않아도 된다.(알고리즘 문제 풀이의 경우)

#### big-O 표기시 규칙

1. **계수 및 상수항은 무시한다**

	`O(2n + 3) -> O(n) `
	
2. **지배적이지 않은 항은 무시한다**

	`O(n^2 + n) -> O(n^2)`


문제의 크기 N에 대해 시간 복잡도를 계산해보고 작성한 코드가 대략 얼만큼의 시간이 걸릴지 예상할 수 있다.
시간 복잡도 안에 가장 큰 입력 범위를 넣었을 때, `1억번의 연산이 1초`정도 걸린다고 한다.

예를들어, 문제의 크기(N)이 10만이고 시간복잡도가

  - O(1) 인 경우 :  1번의 연산 = 1/100000000초
  - O(N) 인 경우 :  10만번의 연산 = 1/1000 초
  - O(N²) 인 경우 :  100억번의 연산 = 100초 

소요된다고 계산할 수 있다. 따라서 시간제한(보통의 경우 1초)이 걸려있는 문제의 경우 내가 짠 알고리즘의 시간복잡도를 계산해보고 시간 내에 수행될 지 판단해보자.
 

![asymptotic runtime](https://media.vlpt.us/images/realryankim/post/29965e56-046a-4fd6-86ff-6d94c90e96fd/big-o-chart-tutorial-bazar-aymptotic-notations-1.png)

